it('should log an error when getLocationList() fails', () => {
    const errorMessage = 'Error fetching the location list!!!';
    const mockUBMCommonService = jasmine.createSpyObj('UBMCommonService', ['getLocationList']);
    mockUBMCommonService.getLocationList.and.returnValue(throwError(errorMessage)); 
    component.ubmCommonService = mockUBMCommonService;
    spyOn(console, 'log');
    component.getLocationList();
    setTimeout(() => {
      expect(console.log).toHaveBeenCalledWith(errorMessage);
    }, 0);
  });


 it('should log an error when getCurrencySymbolList() fails', fakeAsync(() => {
    const errorMessage = 'Error fetching the currency list!!!';
    const mockUBMCommonService = jasmine.createSpyObj('UBMCommonService', ['getCurrencySymbolList']);
    mockUBMCommonService.getCurrencySymbolList.and.returnValue(throwError(errorMessage)); 
    component.ubmCommonService = mockUBMCommonService;
    spyOn(console, 'log');
    component.getCurrencySymbolList();
    tick();
    expect(console.log).toHaveBeenCalledWith(errorMessage);
  }));


it('should populate facilityList when getLocationList() is successful', () => {
  const facilityList = [
    {
      Id: '1',
      Name: 'Asset Manager - Location',
    },
    {
      Id: '2',
      Name: 'Energy Location MR',
    },
  ];
  window.sessionStorage['UserRoleId'] = 1;
  mockUBMCommonService.getLocationList.and.returnValue(of(facilityList));
  component.getLocationList();
  expect(component.facilityList).toEqual([]);
});



  it('should fetch and process years correctly when getYearList is called', () => {
    const mockYears = [2022, 2023]; 

    invoiceYearService.getInvoiceYears.and.returnValue(of(mockYears));
    component.getYearList();
    expect(component.YearList).toEqual(mockYears);
    expect(component.Year.length).toBe(mockYears.length);
    });

it('should update properties and call getInvoiceDetails when apply() is called', () => {

    const mockYear = [
      { Year: 2022, IsYearDisabled: false, IsChecked: true },
      { Year: 2023, IsYearDisabled: true, IsChecked: false },
    ];

    component.Year = mockYear;
    component.isLoading = false;
    component.invoiceYearApplyClicked = false;
    component.showDropDown = true;
    component.tempResult = [];

    spyOn(component, 'getInvoiceDetails');

    component.apply();

    expect(component.isLoading).toBe(true);
    expect(component.invoiceYearApplyClicked).toBe(true);
    expect(component.showDropDown).toBe(false);
    expect(component.tempResult).toEqual([]);
    expect(component.getInvoiceDetails).toHaveBeenCalled();

    expect(component.retainInvoiceYearList).toEqual(mockYear);
  });

  it('should reset dropdown properties and call GetAllDropdownLists when resetDropdown() is called ', () => {
    component.locationClicked = true;
    component.buildingClicked = true;
    component.providerClicked = true;
    component.accountNumberClicked = true;
    component.premiseIdClicked = true;
    component.invoiceInformation.locationId = '123';
    component.invoiceInformation.buildingId = '456';
    component.invoiceInformation.providerId = 789;
    component.invoiceInformation.accountNumber = 'ABC';
    component.locationName = 'LocationName';
    component.buildingName = 'BuildingName';
    component.providerName = 'ProviderName';
    component.accountName = 'AccountName';
    component.premisesName = 'PremisesName';
    component.utilityType = 'UtilityType';
    component.accountGroupNumber = 'AccountGroupNumber';
    component.premiseNumberList = [1, 2, 3];
    component.searchTextLocation = 'SearchTextLocation';
    component.searchTextBuilding = 'SearchTextBuilding';
    component.searchTextProvider = 'SearchTextProvider';
    component.searchTextAccountNumber = 'SearchTextAccountNumber';
    component.searchTextPremisesId = 'SearchTextPremisesId';
    spyOn(component, 'GetAllDropdownLists');
    component.resetDropdown();
    expect(component.locationClicked).toBe(false);
    expect(component.buildingClicked).toBe(false);
    expect(component.providerClicked).toBe(false);
    expect(component.accountNumberClicked).toBe(false);
    expect(component.premiseIdClicked).toBe(false);
    expect(component.invoiceInformation.locationId).toBe('');
    expect(component.GetAllDropdownLists).toHaveBeenCalled();
  });


it('should update PremiseNumber when onPremiseNumberChange() is called', () => {

    component.premiseIdClicked = false;
    component.invoiceInformation.premiseNumber = '123';
    component.premisesName = 'PremisesName';
    component.searchTextPremisesId = 'SearchTextPremisesId';
    component.isPremiseDropdownOpen = true;

    const mockValue = '456';
    component.onPremiseNumberChange(mockValue);

    expect(component.premiseIdClicked).toBe(true);
    expect(component.invoiceInformation.premiseNumber).toBe(mockValue);
    expect(component.premisesName).toBe(mockValue);
    expect(component.searchTextPremisesId).toBe('');
    expect(component.isPremiseDropdownOpen).toBe(false);
  });

it('should call CommonService methods when ngOnDestroy() is called', () => {
 
    spyOn(commonService, 'setInvoiceSummaryExpanded');
    spyOn(commonService, 'setInvoiceSummaryEnabled');
    spyOn(commonService, 'enableUtilitySection');

    component.ngOnDestroy();

    expect(commonService.setInvoiceSummaryExpanded).toHaveBeenCalledWith(false);
    expect(commonService.setInvoiceSummaryEnabled).toHaveBeenCalledWith(false);
    expect(commonService.enableUtilitySection).toHaveBeenCalledWith(false);
  });


it('should update properties when apply() is called', () => {

    const mockYear = [
      { Year: 2022, IsYearDisabled: false, IsChecked: true },
      { Year: 2023, IsYearDisabled: true, IsChecked: false },
    ];

    component.Year = mockYear;
    component.isLoading = false;
    component.invoiceYearApplyClicked = false;
    component.showDropDown = true;
    component.tempResult = [];

    spyOn(component, 'getInvoiceDetails');

    component.apply();

    expect(component.isLoading).toBe(true);
    expect(component.invoiceYearApplyClicked).toBe(true);
    expect(component.showDropDown).toBe(false);
    expect(component.tempResult).toEqual([]);
    expect(component.getInvoiceDetails).toHaveBeenCalled();

    expect(component.retainInvoiceYearList).toEqual(mockYear);
  });



 it('should apply filter when retainFilterArray is not empty', () => {
    // Set up initial data for testing
    component.actualInvoiceData = /* set up your test data here */;
    component.filteredResult = /* set up your test data here */;
    component.retainFilterArray = /* set up your test data here */;

    // Call applyResetFilter
    component.applyResetFilter();

    // Make assertions based on your specific test data and logic
    expect(component.gridApplyFilterResult).toEqual(/* expected result based on your test data and logic */);
    expect(component.totalItem).toBe(/* expected value */);
    expect(component.result).toEqual(/* expected result based on your test data and logic */);
    expect(component.nooffilters).toBe(/* expected value */);

    // Verify other conditions and expectations as needed
  });

  it('should reset filter when retainFilterArray is empty', () => {
    // Set up initial data for testing when retainFilterArray is empty
    component.actualInvoiceData = /* set up your test data here */;
    component.filteredResult = /* set up your test data here */;
    component.retainFilterArray = []; // Empty array

    component.applyResetFilter();

    // Make assertions based on your specific test data and logic for the reset scenario
    expect(component.gridApplyFilterResult).toEqual(/* expected result based on your test data and logic for reset */);
    expect(component.totalItem).toBe(/* expected value for reset */);
    expect(component.result).toEqual(/* expected result based on your test data and logic for reset */);
    expect(component.nooffilters).toBe(/* expected value for reset */);

  });


it('should add value to checkedList when status is true when getSelectedValue() is called', () => {

    component.checkedList = ['Value1', 'Value2'];
    component.Year = [
      { IsChecked: false },
      { IsChecked: false },
    ];

    component.getSelectedValue(true, 'Value3');


    expect(component.checkedList).toEqual(['Value1', 'Value2', 'Value3']);
  });

  it('should remove value from checkedList when status is false when getSelectedValue() is called', () => {
 
    component.checkedList = ['Value1', 'Value2', 'Value3'];
    component.Year = [
      { IsChecked: false },
      { IsChecked: false },
    ];

    component.getSelectedValue(false, 'Value2');

    expect(component.checkedList).toEqual(['Value1', 'Value3']);
  });

  it('should disable Year items when more than 3 values are checked when getSelectedValue() is called', () => {

    component.Year = [
      { IsChecked: false, IsYearDisabled: false },
      { IsChecked: false, IsYearDisabled: false },
      { IsChecked: false, IsYearDisabled: false },
    ];

    component.checkedList = ['Value1', 'Value2', 'Value3'];

    component.getSelectedValue(true, 'Value4');

    expect(component.Year[0].IsYearDisabled).toBe(true);
    expect(component.Year[1].IsYearDisabled).toBe(true);
    expect(component.Year[2].IsYearDisabled).toBe(true);
  });

  it('should enable all Year items when 3 or fewer values are checked when getSelectedValue() is called', () => {

    component.Year = [
      { IsChecked: false, IsYearDisabled: true },
      { IsChecked: false, IsYearDisabled: true },
      { IsChecked: false, IsYearDisabled: true },
    ];

    component.checkedList = ['Value1', 'Value2', 'Value3'];

    component.getSelectedValue(false, 'Value1');

    expect(component.Year[0].IsYearDisabled).toBe(false);
    expect(component.Year[1].IsYearDisabled).toBe(false);
    expect(component.Year[2].IsYearDisabled).toBe(false);
  });
it('should reset component properties when reset() is called', () => {
 
    component.reset();

    expect(component.invoiceYearApplyClicked).toBe(false);
    expect(component.selectedStartDate).toBeUndefined();
    expect(component.selectedEndDate).toBeUndefined();
    expect(component.customRange).toBe(false);
    expect(component.showDateRange).toBe(false);
  });
it('should update selectAllRows to true when updateSelectedAllState() is called', () => {

    component.updateSelectedAllState();

    expect(component.selectAllRows).toBe(true);
    expect(component.indeterminate).toBe(false);
  });

  it('should update selectAllRows to false  when updateSelectedAllState() is called', () => {
 
    component.result.forEach((item) => {
      item.IsRowChecked = false;
    });

    component.updateSelectedAllState();

    expect(component.selectAllRows).toBe(false);
    expect(component.indeterminate).toBe(false);
  });

  it('should set indeterminate to true when some items are checked when updateSelectedAllState() is called', () => {

    component.result[0].IsRowChecked = false;

    component.updateSelectedAllState();

    expect(component.selectAllRows).toBe(false);
    expect(component.indeterminate).toBe(true);
  });



  it('should call AddAccount when AddAccount() is called ', () => {

    const ngFormMock: NgForm = {
      resetForm: () => {}, 
    } as any; 

    component.accountDetails();

    spyOn(UBMCommonService, 'AddAccount').and.returnValue({
      subscribe: (callbacks: any) => {
        callbacks.next(/* Provide a mock result here */);
        callbacks.complete();
      },
    });
    component.addAccount(ngFormMock);
    expect(component.isLoading).toBe(true);
    expect(ubmService.AddAccount).toHaveBeenCalledWith(component.accountDetails);
    expect(ngFormMock.resetForm).toHaveBeenCalled();
  });

it('should set isSubCommodityDropdownOpen to false when clickedoutsideSubCommodity() is called', () => {
    component.clickedoutsideSubCommodity();
    expect(component.isSubCommodityDropdownOpen).toBe(false);
  });


it('should toggle isSubCommodityDropdownOpen property when toggleSubCommodityDropdown() is called', () => {

    const initialValue = component.isSubCommodityDropdownOpen;

    component.toggleSubCommodityDropdown();

    expect(component.isSubCommodityDropdownOpen).toBe(!initialValue); 
  });

it('should reset searchText property to an empty string when resetDropdown() is called', () => {
    component.resetDropdown();
    expect(component.searchText).toBe(''); 
  });

  it('should update properties correctly when onSubCommodityListChange() is called', () => {
  
    const sampleValue = {
      DisplayName: 'Sample Subcommodity',
      Id: 123,
    };

    component.onSubCommodityListChange(sampleValue);

    expect(component.selectedSubcomodity).toBe('Sample Subcommodity');
    expect(component.accountDetails.SubcommodityId).toBe(123);
    expect(component.issubcommodityDropdownOpen).toBe(false);
    expect(component.searchText).toBe('');
  });

it('should delete the account and show success notification when deleteAccount is called', () => {

    const ngFormMock: NgForm = {
      resetForm: () => {},
    } as any; 

 
    spyOn(ubmService, 'deleteAccount').and.returnValue({
      subscribe: (callbacks: any) => {
        callbacks.next(true); 
        callbacks.complete();
      },
    });

    component.deleteAccount(ngFormMock);

    expect(component.isLoading).toBe(true);
    expect(ubmService.deleteAccount).toHaveBeenCalledWith(123); 

    expect(ngFormMock.resetForm).toHaveBeenCalled();

  });

it('should update selectedRowNum correctly based on the provided index when retainRowState() is called', () => {

    const sampleIndex = 2;

    component.retainRowState(sampleIndex);

    expect(component.selectedRowNum).toBe(sampleIndex); 

    component.retainRowState(sampleIndex);

    expect(component.selectedRowNum).toBe(null); 
  });

it('should set invoiceExistModal to true when isInvoiceMapped is true when deleteAccountValidation() is called', () => {

    component.isInvoiceMapped = true;

    component.deleteAccountValidation();

    expect(component.invoiceExistModal).toBe(true); 
  });

  it('should set invoiceExistModal to false when isInvoiceMapped is false when deleteAccountValidation() is called', () => {
  
    component.isInvoiceMapped = false;

    component.deleteAccountValidation();

    expect(component.invoiceExistModal).toBe(false); 
  });


  it('should update the account and show success notification when updateAccount is called successfully when updateAccount is called', () => {

    const ngFormMock: NgForm = {
      resetForm: () => {}, 
    } as any;

    spyOn(ubmService, 'updateAccount').and.returnValue({
      subscribe: (callbacks: any) => {
        callbacks.next(true); 
        callbacks.complete();
      },
    });


    component.updateAccount(ngFormMock);

    expect(component.isLoading).toBe(true);
    expect(component.accountDetails.IsUpdate).toBe(false); 
    expect(component.accountDetails.IsSupplierAccount).toBe('Yes'); 

    expect(ubmService.updateAccount).toHaveBeenCalledWith(component.accountDetails);

    expect(ngFormMock.resetForm).toHaveBeenCalled();

  });

it('should set accountGridData and related properties when getAccountGridData() is called successfully', () => {

    const mockResponse = [
    ];

    spyOn(ubmService, 'getAccountList').and.returnValue(of(mockResponse)); 

    component.getAccountGridData();

    expect(component.isLoading).toBe(false); 
    expect(component.accountGridData).toEqual(mockResponse); 

  });


