it('should delete the account and show success notification when deleteAccount() is called', () => {

    const ngFormMock: NgForm = {
      resetForm: () => {},
    } as any; 

 
    spyOn(UBMCommonService, 'deleteAccount').and.returnValue({
      subscribe: (callbacks: any) => {
        callbacks.next("true"); 
        callbacks.complete();
      },
    });

    component.deleteAccount(ngFormMock);

    expect(component.isLoading).toBe(true);
    expect(ubmService.deleteAccount).toHaveBeenCalledWith(123); 

    expect(ngFormMock.resetForm).toHaveBeenCalled();

  });


it('should update commodityList when getCommodityList() is called successfully', () => {
    const mockResponse = [
      // Add sample commodity data here
    ];
    spyOn(UBMCommonService, 'getCommodityList').and.returnValue(of(mockResponse)); 
    component.getCommodityList();
    expect(component.commodityList).toEqual(mockResponse); 
  });

it('should update providerList when getProviderList() is called successfully', () => {

    const mockResponse = [
      // Add sample provider data here
    ];

    spyOn(UBMCommonService, 'getProviderList').and.returnValue(of(mockResponse)); 

    component.getProviderList();

    expect(component.providerList).toEqual(mockResponse); 

  });

it('should update accountTypeList when getAccountType() is called successfully', () => {
    const mockResponse = [
      // Add sample account type data here
    ];
    spyOn(ubmService, 'getAccountType').and.returnValue(of(mockResponse)); 

    component.getAccountType();

    expect(component.accountTypeList).toEqual(mockResponse); 

  });

it('should set onlyUrjanetLicense to true when isUjanetLicenseExistAndActive() returns true', () => {

    spyOn(commonService, 'isUjanetLicenseExistAndActive').and.returnValue(true);

    component.checkUrjanetLicense();

    expect(component.onlyUrjanetLicense).toBe(true); 
  });

  it('should set onlyUrjanetLicense to false when isUjanetLicenseExistAndActive() returns false', () => {

    spyOn(commonService, 'isUjanetLicenseExistAndActive').and.returnValue(false);

    component.checkUrjanetLicense();

    expect(component.onlyUrjanetLicense).toBe(false); 
  });



it('should reset accountDetails and mark form as untouched when clearForm() is called', () => {
  
    component.accountDetails = { /* Initial accountDetails values */ };
    component.filterText = 'Initial filter text';

    const mockForm: NgForm = {
      form: {
        markAsUntouched: jasmine.createSpy('markAsUntouched'), 
      },
    } as any; 

    component.clearForm(mockForm);

    expect(component.accountDetails).toEqual(new Account()); 
    expect(component.filterText).toBe(''); 
    expect(mockForm.form.markAsUntouched).toHaveBeenCalled(); 

  });


it('should update the account when updateAccount() is called', () => {
    spyOn(yourService, 'updateAccount').and.returnValue(of(true));
    component.updateAccount({} as NgForm); 
    expect(component.isLoading).toBe(false); 
  });

  it('should handle an error when updateAccount() is called', () => {
    spyOn(yourService, 'updateAccount').and.returnValue(throwError('Some error'));
    component.updateAccount({} as NgForm);
    expect(component.isLoading).toBe(false); 

  });



 it('should return true when checkDuplicate() is called', () => {
    component.accountDetails ;
    component.accountGridPageData;

    const mockForm: NgForm = {
      form: {
        markAsUntouched: jasmine.createSpy('markAsUntouched'), // Spy on markAsUntouched
      },
    } as any;

    const result = component.checkDuplicate('add', mockForm);

    expect(result).toBe(true); 
    expect(mockForm.form.markAsUntouched).toHaveBeenCalled(); 

  });

  it('should return true and clear the form when editingwhen checkDuplicate() is called', () => {
  
    component.accountDetails = { accountId: 1 };

    const mockForm: NgForm = {
      form: {
        markAsUntouched: jasmine.createSpy('markAsUntouched'),
      },
    } as any; 

    const result = component.checkDuplicate('edit', mockForm);

    expect(result).toBe(true); 
    expect(mockForm.form.markAsUntouched).toHaveBeenCalled(); 
  });
