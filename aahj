
  it('should toggle showDropDown property and update buttonsDisabled when toggleMenu() Is called', () => {
    // Initial state
    component.showDropDown = false;
    component.Year = [
      { IsChecked: true },
      { IsChecked: true },
      { IsChecked: true },
    ];

    component.toggleMenu();
    expect(component.showDropDown).toBe(true);
    expect(component.buttonsDisabled).toBe(true);
    component.toggleMenu();
    expect(component.showDropDown).toBe(false);
    component.Year = [
      { IsChecked: true },
      { IsChecked: false },
      { IsChecked: true },
    ];
    component.toggleMenu();
    expect(component.buttonsDisabled).toBe(false);
  });

it('should toggle IsRowExpanded when toggleRowMenu is called', () => {
    const sampleData: InvoiceDetailsForGrid = { IsRowExpanded: false };
    component.toggleRowMenu(sampleData);
    expect(sampleData.IsRowExpanded).toBe(true);
    component.toggleRowMenu(sampleData);
    expect(sampleData.IsRowExpanded).toBe(false);
  });

 it('should update showDropDown and Year  when clickedOutside() is called', () => {
    component.showDropDown = true;
    component.retainInvoiceYearList = [
      { Year: 2021, IsYearDisabled: false, IsChecked: true },
      { Year: 2022, IsYearDisabled: true, IsChecked: false },
    ];
    component.clickedOutside();
    expect(component.showDropDown).toBe(false);
    expect(component.Year).toEqual([
      { Year: 2021, IsYearDisabled: false, IsChecked: true },
      { Year: 2022, IsYearDisabled: true, IsChecked: false },
    ]);
    expect(component.checkedList).toEqual([2021]);
  });


 it('should set showClearAll when clickedOutsideFilterIcon() is called', () => {
    component.showClearAll = true;
    component.clickedOutsideFilterIcon();
    expect(component.showClearAll).toBe(false);
  });

it('should set isFilterApplyDisable to false and call toggleFilterSelection when getSelectedFilterData() is called', () => {
    
    component.isFilterApplyDisable = true;

    const filterResult = { 1,2,3 };

    spyOn(component, 'toggleFilterSelection');

    component.getSelectedFilterData(filterResult);

    expect(component.isFilterApplyDisable).toBe(false);

    expect(component.toggleFilterSelection).toHaveBeenCalledWith(filterResult);
  });

it('should set isFilterApplyDisable to false and showDateRange when getSelectedUpdatedDateTime() is called', () => {
    component.isFilterApplyDisable = true;
    component.selectedDateRange = "calenderCustomRange";
    component.retainSelectedRadioState = "calender CustomRange";
    component.getSelectedUpdatedDateTime();
    expect(component.isFilterApplyDisable).toBe(false);
    expect(component.showDateRange).toBe(true);
    component.showDateRange = false;
    component.selectedDateRange = "anotherValue";
    component.retainSelectedRadioState = "anotherValue";
    component.getSelectedUpdatedDateTime();
    expect(component.isFilterApplyDisable).toBe(false);
    expect(component.showDateRange).toBe(false);
  });

it('should handle an empty string when removeNumberComma() is caled', () => {
    const objName = '';
    const result = component.removeNumberComma(objName);
    expect(result).toBe('');
  });

  it('should handle a string with no non-numeric characters when removeNumberComma() is caled', () => {
    const objName = '123456';
    const result = component.removeNumberComma(objName);
    expect(result).toBe(objName);
  });




it('should bind grid data when bindGridData() is called ', () => {
    const sampleData = [1,2];
    component.result = sampleData;

    component.pageSize = 10;

    component.bindGridData();

    expect(component.totalItem).toBe(sampleData.length);

    expect(component.result).toEqual(sampleData.slice(0, component.pageSize));

    expect(component.pageContent.emit).toHaveBeenCalledWith(component.result);

    expect(component.endRowNum).toBe(
      sampleData.length > 0 ? Math.min(component.totalItem + 1, component.pageSize) : undefined
    );
 
    expect(component.totalItems).toBe(
      sampleData.length > 0 ? Math.ceil(component.totalItem / component.pageSize) : 1
    );
  
    expect(component.isLoading).toBe(false);
  });


it('should sort the array in ascending order when sortByInteger() is called ', () => {
    const sortArray = [
      { name: '3' },
      { name: '1' },
      { name: '2' },
      { name: '5' },
    ];
    component.orderType = 'asc';
    const result = component.sortByInteger(sortArray, { name: 'name' });
    expect(result).toEqual([
      { name: '1' },
      { name: '2' },
      { name: '3' },
      { name: '5' },
    ]);
  });

  it('should sort the array in descending order when sortByInteger() is called', () => {
    const sortArray = [
      { name: '3' },
      { name: '1' },
      { name: '2' },
      { name: '5' },
    ];

    component.orderType = 'desc';
    const result = component.sortByInteger(sortArray, { name: 'name' });
    expect(result).toEqual([
      { name: '5' },
      { name: '3' },
      { name: '2' },
      { name: '1' },
    ]);
  });
it('should sort the array by date in ascending order when sortByDate() is called ', () => {
   
    const sortArray = [
      { date: '2023-09-01' },
      { date: '2023-08-15' },
      { date: '2023-09-10' },
    ];

    component.orderType = 'asc';

 
    const result = component.sortByDate(sortArray, { name: 'date' });

    expect(result).toEqual([
      { date: '2023-08-15' },
      { date: '2023-09-01' },
      { date: '2023-09-10' },
    ]);
  });

  it('should sort the array by date in descending order when sortByDate() is called', () => {
  
    const sortArray = [
      { date: '2023-09-01' },
      { date: '2023-08-15' },
      { date: '2023-09-10' },
    ];

    component.orderType = 'desc';

    const result = component.sortByDate(sortArray, { name: 'date' });

    expect(result).toEqual([
      { date: '2023-09-10' },
      { date: '2023-09-01' },
      { date: '2023-08-15' },
    ]);
  });


 it('should fetch year list and perform necessary operations when getYearList() is called', fakeAsync(() => {
    
    const yearList = [2021, 2022, 2023];

    window.sessionStorage['UserRoleID'] = 'someRoleID';

    invoiceYearService.getInvoiceYears.and.returnValue(of(yearList));

    component.getYearList();

    expect(component.YearList).toEqual(yearList);


    window.sessionStorage['UserRoleID'] = null;
    component.getYearList();
    expect(invoiceYearService.getInvoiceYears).not.toHaveBeenCalled();
  }));



 it('should sort the array alphabetically and numerically in ascending order when sortByAlphalium() is called', () => {
    const sortArray = [
      { name: 'Item 3' },
      { name: 'Item 1' },
      { name: 'Item 10' },
      { name: 'Item 2' },
      { name: 'Item 20' },
    ];
    component.orderType = 'asc';
    const result = component.sortByAlphalium(sortArray, { name: 'name' });
    expect(result).toEqual([
      { name: 'Item 1' },
      { name: 'Item 2' },
      { name: 'Item 3' },
      { name: 'Item 10' },
      { name: 'Item 20' },
    ]);
  });

  it('should sort the array alphabetically and numerically in descending order when sortByAlphalium() is called', () => {
    const sortArray = [
      { name: 'Item 3' },
      { name: 'Item 1' },
      { name: 'Item 10' },
      { name: 'Item 2' },
      { name: 'Item 20' },
    ];
    component.orderType = 'desc';
    const result = component.sortByAlphalium(sortArray, { name: 'name' });

    expect(result).toEqual([
      { name: 'Item 20' },
      { name: 'Item 10' },
      { name: 'Item 3' },
      { name: 'Item 2' },
      { name: 'Item 1' },
    ]);
  });


 it('should filter data for the last 7 days when selectedDateRange()', () => {
    const GridApplyResult = [
      { UpdatedDateAndTime: moment().subtract(5, 'd').toDate() },
      { UpdatedDateAndTime: moment().subtract(8, 'd').toDate() },
      { UpdatedDateAndTime: moment().subtract(2, 'd').toDate() },
    ];
    component.selectedDateRange = 'last7';
    component.calculatePastDaysData(GridApplyResult);
    expect(component.filteredResult.length).toBe(2); 
  });

it('should reset the Year array when resetInvoiceYear() is called', () => {
    const Year = [
      { Year: 2021, IsChecked: false, IsYearDisabled: false },
      { Year: 2022, IsChecked: false, IsYearDisabled: false },
      { Year: 2023, IsChecked: false, IsYearDisabled: false },
      { Year: 2024, IsChecked: false, IsYearDisabled: false },
    ];
    component.Year = Year;

    component.resetInvoiceYear();

    expect(component.Year[0].IsChecked).toBe(true);
    expect(component.Year[1].IsChecked).toBe(true);
    expect(component.Year[2].IsChecked).toBe(true);
    expect(component.Year[3].IsChecked).toBe(false);

    expect(component.Year[0].IsYearDisabled).toBe(false);
    expect(component.Year[1].IsYearDisabled).toBe(false);
    expect(component.Year[2].IsYearDisabled).toBe(false);
    expect(component.Year[3].IsYearDisabled).toBe(true);
    expect(component.checkedList).toEqual([2021, 2022, 2023]);
  });

it('should update showDateRange when selectedDateRange and retainSelectedRadioState match when getSelectedUpdatedDateTime() is called', () => {
 
    component.selectedDateRange = 'calenderCustomRange';
    component.retainSelectedRadioState = 'calender CustomRange';

    component.getSelectedUpdatedDateTime();

    expect(component.showDateRange).toBe(true);
  });

  it('should not update showDateRange when selectedDateRange and retainSelectedRadioState do not matchwhen getSelectedUpdatedDateTime() is called', () => {
    component.selectedDateRange = 'calenderCustomRange';
    component.retainSelectedRadioState = 'differentValue';

    component.getSelectedUpdatedDateTime();

    expect(component.showDateRange).toBe(false);
  });


it('should apply a filter when isDeleteFilter or selectAllFilter is false when applyGridfilter() is called', () => {

    const invoice = { name: 'SampleColumn' };
 
    component.isDeleteFilter = false;
    component.selectAllFilter = false;


    component.applyGridfilter(invoice);

    expect(component.retainFilterArray.length).toBe(1); 

  });

  it('should remove a filter when isDeleteFilter or selectAllFilter is true when applyGridfilter() is called', () => {

    const invoice = { name: 'SampleColumn' };

    component.isDeleteFilter = true;
    component.selectAllFilter = true;

    component.retainFilterArray = [{ name: 'SampleColumn' }];

    component.applyGridfilter(invoice);

    expect(component.retainFilterArray.length).toBe(0);

  });


 it('should reset filters and update gridApplyFilterResult and totalItem when retainFilterArray is empty', () => {

    component.retainFilterArray = [];

    component.actualInvoiceData = [{}, {}]; 

    component.applyResetFilter();

    expect(component.retainFilterArray.length).toBe(0);
    expect(component.gridApplyFilterResult).toEqual(component.actualInvoiceData);
    expect(component.totalItem).toBe(component.actualInvoiceData.length);
  });

  it('should apply filters and update gridApplyFilterResult and totalItem when retainFilterArray is not empty', () => {
  
    component.retainFilterArray = [
      { name: 'UpdatedDateAndTime', filterlist: [{ name: 'SampleFilter', IsChecked: true }], isFirstFilter: true },
    ];

    component.actualInvoiceData = [{}, {}];
    component.filteredResult = component.actualInvoiceData.slice();

    component.applyResetFilter();

    expect(component.retainFilterArray.length).toBe(0);
    expect(component.gridApplyFilterResult.length).toBeGreaterThan(0); // Check if gridApplyFilterResult is updated
    expect(component.totalItem).toBe(component.gridApplyFilterResult.length);
  });
