
  it('should toggle showDropDown property and update buttonsDisabled when toggleMenu() Is called', () => {
    // Initial state
    component.showDropDown = false;
    component.Year = [
      { IsChecked: true },
      { IsChecked: true },
      { IsChecked: true },
    ];

    component.toggleMenu();
    expect(component.showDropDown).toBe(true);
    expect(component.buttonsDisabled).toBe(true);
    component.toggleMenu();
    expect(component.showDropDown).toBe(false);
    component.Year = [
      { IsChecked: true },
      { IsChecked: false },
      { IsChecked: true },
    ];
    component.toggleMenu();
    expect(component.buttonsDisabled).toBe(false);
  });

it('should toggle IsRowExpanded when toggleRowMenu is called', () => {
    const sampleData: InvoiceDetailsForGrid = { IsRowExpanded: false };
    component.toggleRowMenu(sampleData);
    expect(sampleData.IsRowExpanded).toBe(true);
    component.toggleRowMenu(sampleData);
    expect(sampleData.IsRowExpanded).toBe(false);
  });

 it('should update showDropDown and Year  when clickedOutside() is called', () => {
    component.showDropDown = true;
    component.retainInvoiceYearList = [
      { Year: 2021, IsYearDisabled: false, IsChecked: true },
      { Year: 2022, IsYearDisabled: true, IsChecked: false },
    ];
    component.clickedOutside();
    expect(component.showDropDown).toBe(false);
    expect(component.Year).toEqual([
      { Year: 2021, IsYearDisabled: false, IsChecked: true },
      { Year: 2022, IsYearDisabled: true, IsChecked: false },
    ]);
    expect(component.checkedList).toEqual([2021]);
  });


 it('should set showClearAll when clickedOutsideFilterIcon() is called', () => {
    component.showClearAll = true;
    component.clickedOutsideFilterIcon();
    expect(component.showClearAll).toBe(false);
  });

it('should set isFilterApplyDisable to false and call toggleFilterSelection when getSelectedFilterData() is called', () => {
    
    component.isFilterApplyDisable = true;

    const filterResult = { 1,2,3 };

    spyOn(component, 'toggleFilterSelection');

    component.getSelectedFilterData(filterResult);

    expect(component.isFilterApplyDisable).toBe(false);

    expect(component.toggleFilterSelection).toHaveBeenCalledWith(filterResult);
  });

it('should set isFilterApplyDisable to false and showDateRange when getSelectedUpdatedDateTime() is called', () => {
    component.isFilterApplyDisable = true;
    component.selectedDateRange = "calenderCustomRange";
    component.retainSelectedRadioState = "calender CustomRange";
    component.getSelectedUpdatedDateTime();
    expect(component.isFilterApplyDisable).toBe(false);
    expect(component.showDateRange).toBe(true);
    component.showDateRange = false;
    component.selectedDateRange = "anotherValue";
    component.retainSelectedRadioState = "anotherValue";
    component.getSelectedUpdatedDateTime();
    expect(component.isFilterApplyDisable).toBe(false);
    expect(component.showDateRange).toBe(false);
  });

it('should handle an empty string when removeNumberComma() is caled', () => {
    const objName = '';
    const result = component.removeNumberComma(objName);
    expect(result).toBe('');
  });

  it('should handle a string with no non-numeric characters when removeNumberComma() is caled', () => {
    const objName = '123456';
    const result = component.removeNumberComma(objName);
    expect(result).toBe(objName);
  });




it('should bind grid data when bindGridData() is called ', () => {
    const sampleData = [1,2];
    component.result = sampleData;

    component.pageSize = 10;

    component.bindGridData();

    expect(component.totalItem).toBe(sampleData.length);

    expect(component.result).toEqual(sampleData.slice(0, component.pageSize));

    expect(component.pageContent.emit).toHaveBeenCalledWith(component.result);

    expect(component.endRowNum).toBe(
      sampleData.length > 0 ? Math.min(component.totalItem + 1, component.pageSize) : undefined
    );
 
    expect(component.totalItems).toBe(
      sampleData.length > 0 ? Math.ceil(component.totalItem / component.pageSize) : 1
    );
  
    expect(component.isLoading).toBe(false);
  });


it('should sort the array in ascending order when sortByInteger() is called ', () => {
    const sortArray = [
      { name: '3' },
      { name: '1' },
      { name: '2' },
      { name: '5' },
    ];
    component.orderType = 'asc';
    const result = component.sortByInteger(sortArray, { name: 'name' });
    expect(result).toEqual([
      { name: '1' },
      { name: '2' },
      { name: '3' },
      { name: '5' },
    ]);
  });

  it('should sort the array in descending order when sortByInteger() is called', () => {
    const sortArray = [
      { name: '3' },
      { name: '1' },
      { name: '2' },
      { name: '5' },
    ];

    component.orderType = 'desc';
    const result = component.sortByInteger(sortArray, { name: 'name' });
    expect(result).toEqual([
      { name: '5' },
      { name: '3' },
      { name: '2' },
      { name: '1' },
    ]);
  });
it('should sort the array by date in ascending order when sortByDate() is called ', () => {
   
    const sortArray = [
      { date: '2023-09-01' },
      { date: '2023-08-15' },
      { date: '2023-09-10' },
    ];

    component.orderType = 'asc';

 
    const result = component.sortByDate(sortArray, { name: 'date' });

    expect(result).toEqual([
      { date: '2023-08-15' },
      { date: '2023-09-01' },
      { date: '2023-09-10' },
    ]);
  });

  it('should sort the array by date in descending order when sortByDate() is called', () => {
  
    const sortArray = [
      { date: '2023-09-01' },
      { date: '2023-08-15' },
      { date: '2023-09-10' },
    ];

    component.orderType = 'desc';

    const result = component.sortByDate(sortArray, { name: 'date' });

    expect(result).toEqual([
      { date: '2023-09-10' },
      { date: '2023-09-01' },
      { date: '2023-08-15' },
    ]);
  });


 it('should fetch year list and perform necessary operations when getYearList() is called', fakeAsync(() => {
    
    const yearList = [2021, 2022, 2023];

    window.sessionStorage['UserRoleID'] = 'someRoleID';

    invoiceYearService.getInvoiceYears.and.returnValue(of(yearList));

    component.getYearList();

    expect(component.YearList).toEqual(yearList);


    window.sessionStorage['UserRoleID'] = null;
    component.getYearList();
    expect(invoiceYearService.getInvoiceYears).not.toHaveBeenCalled();
  }));



 it('should sort the array alphabetically and numerically in ascending order when sortByAlphalium() is called', () => {
    const sortArray = [
      { name: 'Item 3' },
      { name: 'Item 1' },
      { name: 'Item 10' },
      { name: 'Item 2' },
      { name: 'Item 20' },
    ];
    component.orderType = 'asc';
    const result = component.sortByAlphalium(sortArray, { name: 'name' });
    expect(result).toEqual([
      { name: 'Item 1' },
      { name: 'Item 2' },
      { name: 'Item 3' },
      { name: 'Item 10' },
      { name: 'Item 20' },
    ]);
  });

  it('should sort the array alphabetically and numerically in descending order when sortByAlphalium() is called', () => {
    const sortArray = [
      { name: 'Item 3' },
      { name: 'Item 1' },
      { name: 'Item 10' },
      { name: 'Item 2' },
      { name: 'Item 20' },
    ];
    component.orderType = 'desc';
    const result = component.sortByAlphalium(sortArray, { name: 'name' });

    expect(result).toEqual([
      { name: 'Item 20' },
      { name: 'Item 10' },
      { name: 'Item 3' },
      { name: 'Item 2' },
      { name: 'Item 1' },
    ]);
  });


 it('should filter data for the last 7 days when selectedDateRange()', () => {
    const GridApplyResult = [
      { UpdatedDateAndTime: moment().subtract(5, 'd').toDate() },
      { UpdatedDateAndTime: moment().subtract(8, 'd').toDate() },
      { UpdatedDateAndTime: moment().subtract(2, 'd').toDate() },
    ];
    component.selectedDateRange = 'last7';
    component.calculatePastDaysData(GridApplyResult);
    expect(component.filteredResult.length).toBe(2); 
  });

it('should reset the Year array when resetInvoiceYear() is called', () => {
    const Year = [
      { Year: 2021, IsChecked: false, IsYearDisabled: false },
      { Year: 2022, IsChecked: false, IsYearDisabled: false },
      { Year: 2023, IsChecked: false, IsYearDisabled: false },
      { Year: 2024, IsChecked: false, IsYearDisabled: false },
    ];
    component.Year = Year;

    component.resetInvoiceYear();

    expect(component.Year[0].IsChecked).toBe(true);
    expect(component.Year[1].IsChecked).toBe(true);
    expect(component.Year[2].IsChecked).toBe(true);
    expect(component.Year[3].IsChecked).toBe(false);

    expect(component.Year[0].IsYearDisabled).toBe(false);
    expect(component.Year[1].IsYearDisabled).toBe(false);
    expect(component.Year[2].IsYearDisabled).toBe(false);
    expect(component.Year[3].IsYearDisabled).toBe(true);
    expect(component.checkedList).toEqual([2021, 2022, 2023]);
  });

it('should update showDateRange when selectedDateRange and retainSelectedRadioState match when getSelectedUpdatedDateTime() is called', () => {
 
    component.selectedDateRange = 'calenderCustomRange';
    component.retainSelectedRadioState = 'calender CustomRange';

    component.getSelectedUpdatedDateTime();

    expect(component.showDateRange).toBe(true);
  });

  it('should not update showDateRange when selectedDateRange and retainSelectedRadioState do not matchwhen getSelectedUpdatedDateTime() is called', () => {
    component.selectedDateRange = 'calenderCustomRange';
    component.retainSelectedRadioState = 'differentValue';

    component.getSelectedUpdatedDateTime();

    expect(component.showDateRange).toBe(false);
  });


it('should apply a filter when isDeleteFilter or selectAllFilter is false when applyGridfilter() is called', () => {

    const invoice = { name: 'SampleColumn' };
 
    component.isDeleteFilter = false;
    component.selectAllFilter = false;


    component.applyGridfilter(invoice);

    expect(component.retainFilterArray.length).toBe(1); 

  });

  it('should remove a filter when isDeleteFilter or selectAllFilter is true when applyGridfilter() is called', () => {

    const invoice = { name: 'SampleColumn' };

    component.isDeleteFilter = true;
    component.selectAllFilter = true;

    component.retainFilterArray = [{ name: 'SampleColumn' }];

    component.applyGridfilter(invoice);

    expect(component.retainFilterArray.length).toBe(0);

  });


 it('should reset filters and update gridApplyFilterResult and totalItem when retainFilterArray is empty when applyResetFilter() is called', () => {

    component.retainFilterArray = [];

    component.actualInvoiceData = [{}, {}]; 

    component.applyResetFilter();

    expect(component.retainFilterArray.length).toBe(0);
    expect(component.gridApplyFilterResult).toEqual(component.actualInvoiceData);
    expect(component.totalItem).toBe(component.actualInvoiceData.length);
  });

  it('should apply filters and update gridApplyFilterResult and totalItem when retainFilterArray is not empty when applyResetFilter() is called', () => {
  
    component.retainFilterArray = [
      { name: 'UpdatedDateAndTime', filterlist: [{ name: 'SampleFilter', IsChecked: true }], isFirstFilter: true },
    ];

    component.actualInvoiceData = [{}, {}];
    component.filteredResult = component.actualInvoiceData.slice();

    component.applyResetFilter();

    expect(component.retainFilterArray.length).toBe(0);
    expect(component.gridApplyFilterResult.length).toBeGreaterThan(0); // Check if gridApplyFilterResult is updated
    expect(component.totalItem).toBe(component.gridApplyFilterResult.length);
  });


it('should remove a filter from retainFilterArray and update isCurrentFilter when retainFilterArray() is called', () => {

    const columnName = 'SampleColumn';

    component.retainFilterArray = [
      { name: 'SampleColumn1', isCurrentFilter: true },
      { name: 'SampleColumn2', isCurrentFilter: false },
      { name: 'SampleColumn3', isCurrentFilter: false },
    ];


    component.removeFromRetainFilter(columnName);

    expect(component.retainFilterArray.length).toBe(2);
    expect(component.retainFilterArray.some((filter: any) => filter.name === columnName)).toBe(false);

    expect(component.retainFilterArray.every((filter: any) => !filter.isCurrentFilter)).toBe(true);
  });

  it('should do nothing if the filter is not found in when retainFilterArray() is called', () => {
 
    const columnName = 'NonExistentColumn';

    component.retainFilterArray = [
      { name: 'SampleColumn1', isCurrentFilter: true },
      { name: 'SampleColumn2', isCurrentFilter: false },
      { name: 'SampleColumn3', isCurrentFilter: false },
    ];

    component.removeFromRetainFilter(columnName);

    expect(component.retainFilterArray.length).toBe(3);

    expect(component.retainFilterArray.every((filter: any) => !filter.isCurrentFilter)).toBe(true);
  });

it('should update date-related properties and showDateRange when startDate and endDate when datesUpdated() is called', () => {
 
    const event = {
      startDate: moment('2023-01-01'),
      endDate: moment('2023-01-10'),
    };
 
    component.datesUpdated(event);
 
    expect(component.showDateRange).toBe(true);

 
    expect(component.selectedStartDate).toBe('01-01-2023');  
    expect(component.selectedEndDate).toBe('01-10-2023');  
  });

  it('should not update date-related properties and showDateRange when startDate or endDate is null when datesUpdated() is called', () => {
 
    const event = {
      startDate: null,
      endDate: moment('2023-01-10'),
    };

    component.datesUpdated(event);
 
    expect(component.showDateRange).toBe(false);
 
    expect(component.selectedStartDate).toBeUndefined();
    expect(component.selectedEndDate).toBeUndefined();
  });


it('should reset properties when ngOnDestroy is called', () => {
 
    component.invoiceHeader = [
      { clickFlag: true, IsFilter: true, IsAscending: true, IsDescending: true },
      { clickFlag: false, IsFilter: false, IsAscending: false, IsDescending: false },
    ];

    const invoiceData = [
      { IsRowChecked: true },
      { IsRowChecked: false },
    ];
 
    component.ngOnDestroy();
 
    component.invoiceHeader.forEach((v) => {
      expect(v.clickFlag).toBe(false);
      expect(v.IsFilter).toBe(false);
      expect(v.IsAscending).toBe(false);
      expect(v.IsDescending).toBe(false);
    });

    invoiceData.forEach((v) => {
      expect(v.IsRowChecked).toBe(false);
    });
  });



it('should reset date-related properties and flags when resetDateRange() is called', () => {
    // Set up some sample data and initial property values
    component.showDateRange = true;
    component.isFilterApplyDisable = true;
    component.selectedDateRange = 'customRange';
    component.selectedDates = {
      startDate: moment('2023-01-01'),
      endDate: moment('2023-01-10'),
    };

    component.resetDateRange();

    expect(component.showDateRange).toBe(false);
    expect(component.isFilterApplyDisable).toBe(false);
    expect(component.selectedDateRange).toBe('selectAll');
    expect(component.selectedDates.startDate.toISOString()).toBe(moment().toISOString()); // Adjust as needed
    expect(component.selectedDates.endDate.toISOString()).toBe(moment().toISOString()); // Adjust as needed
  });

it('should sort child grid data ascendingly when sortChildBy() is called', () => {

    const childHeader = {
      name: 'SampleColumn',
      dataType: 'int',
      IsAscending: true,
      IsDescending: false,
    };

    component.childResult = [
      { SampleColumn: 3 },
      { SampleColumn: 1 },
      { SampleColumn: 2 },
    ];

    
    component.sortChildBy(childHeader);

    expect(component.childResult[0].SampleColumn).toBe(1);
    expect(component.childResult[1].SampleColumn).toBe(2);
    expect(component.childResult[2].SampleColumn).toBe(3);
  });

  it('should sort child grid data descendingly when sortChildBy() is called', () => {

    const childHeader = {
      name: 'SampleColumn',
      dataType: 'int',
      IsAscending: false,
      IsDescending: true,
    };

    component.childResult = [
      { SampleColumn: 3 },
      { SampleColumn: 1 },
      { SampleColumn: 2 },
    ];

    component.sortChildBy(childHeader);

    expect(component.childResult[0].SampleColumn).toBe(3);
    expect(component.childResult[1].SampleColumn).toBe(2);
    expect(component.childResult[2].SampleColumn).toBe(1);
  });
it('should sort child grid data in ascending order based on columnName when SortChildDataAscBy() is called', () => {
 
    const columnName = 'SampleColumn';

    component.sortorder = 1; 
    component.sortProperty = null; 

    component.childResult = [
      { SampleColumn: 3 },
      { SampleColumn: 1 },
      { SampleColumn: 2 },
    ];

    component.SortChildDataAscBy(columnName);

    expect(component.childResult[0].SampleColumn).toBe(1);
    expect(component.childResult[1].SampleColumn).toBe(2);
    expect(component.childResult[2].SampleColumn).toBe(3);
  });

   it('should add value to checkedList when status is true when getSelectedValue() is called', () => {
  
    component.checkedList = ['Value1', 'Value2'];

    component.getSelectedValue(true, 'NewValue');

    expect(component.checkedList).toEqual(['Value1', 'Value2', 'NewValue']);
  });

  it('should remove value from checkedList when status is false when getSelectedValue() is called', () => {

    component.checkedList = ['Value1', 'Value2', 'Value3'];

    component.getSelectedValue(false, 'Value2');

    expect(component.checkedList).toEqual(['Value1', 'Value3']);
  });

it('should sort data in ascending order based on a specific column when sortBy() is called ', () => {

    const sortingOrder = 'asc';
    const columnName = 'LocationName';
    const expectedSortedData = [...]; 

    component.sortBy(columnName, sortingOrder);

    expect(component.actualInvoiceData).toEqual(expectedSortedData);

  });

  it('should sort data in descending order based on a specific column when sortBy() is called ', () => {

    const sortingOrder = 'desc';
    const columnName = 'LocationName';
    const expectedSortedData = [...]; // Provide expected sorted data

    component.sortBy(columnName, sortingOrder);

    expect(component.actualInvoiceData).toEqual(expectedSortedData);

  });






it('should set actionsClicked to false when clickedOutsideActions() is called', () => {
  
    component.actionsClicked = true;
    component.clickedOutsideActions();
   expect(component.actionsClicked).toBe(false);
  });

it('should set selectAllRows to true and indeterminate to false when all rows are checked when updateSelectedAllState() is called', () => {

    component.result.forEach((item) => (item.IsRowChecked = true));

    component.updateSelectedAllState();

    expect(component.selectAllRows).toBe(true);
    expect(component.indeterminate).toBe(false);
  });

  it('should set selectAllRows to false and indeterminate to false when all rows are unchecked when updateSelectedAllState() is called', () => {

    component.result.forEach((item) => (item.IsRowChecked = false));

    component.updateSelectedAllState();

    expect(component.selectAllRows).toBe(false);
    expect(component.indeterminate).toBe(false);
  });

  it('should set selectAllRows to false and indeterminate to true when some rows are checked and some are unchecked when updateSelectedAllState() is called', () => {

    component.result[0].IsRowChecked = true;
    component.result[1].IsRowChecked = false;

    component.updateSelectedAllState();

    expect(component.selectAllRows).toBe(false);
    expect(component.indeterminate).toBe(true);
  });

it('should set addInvoiceClicked to true when addInvoice() is called', () => {
   
    component.addInvoice();

    expect(component.addInvoiceClicked).toBe(true);
  });

console.log(Array.isArray(this.provider[providerId]));
console.log(Array.isArray(this.provider[providerName]));



it('should set properties correctly when onProviderChange is called', () => {

    const mockProvider = {
      providerId: 100,
      providerName: 'Test Provider',
    };


    component.providerclicked = false;
    component.invoiceInformation = { providerId: 0 }; 
    component.providerName = '';
    component.searchTextProvider = '';
    component.isProviderDropdownOpen = false;
    component.providerSelected = false;
    component.accountsMappingList = []; 

    component.onProviderChange(mockProvider);

  
    expect(component.providerclicked).toBe(true);
    expect(component.invoiceInformation.providerId).toBe(100);
    expect(component.providerName).toBe('Test Provider');
    expect(component.searchTextProvider).toBe('');
    expect(component.isProviderDropdownOpen).toBe(false); 
   
  });
