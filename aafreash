it('should call SubCommodity when getSubCommodity() is called ', () => {
   UBMCommonService.getSubCommodity.and.returnValue(of(mockSubCommodityDataList)); 
  result:subCommodity[];
  mockSubCommodityDataList:SerialNumber;
  component.getSubCommodity();
  expect(UBMCommonService.getSubCommodity).toHaveBeenCalled();
 if (a < b) {
    expect(component.result).toEqual(-1); 
  } else if(a > b) {
    expect(component.result).toEqual(1); 
  }
  else{
     expect(component.result).toEqual(0); 
  }
  expect(component.subCommodityList).toEqual(mockSubCommodityDataList);
});



it('should Sort SubCommodity when getSubCommodity() is called', () => {
  const subCommodityData: SubCommodity = [{mockSubCommodityDatalist}];
  spyOn(UBMCommonService, 'getSubCommodity').and.returnValue(of(mockSubCommodityDatalist));
  component.getSubCommodity();
  expect(component.subcommodityList).toEqual([{mockSubCommodityDatalist}]);
});


it('should Sort SubCommodity when getSubCommodity() is called', () => {
  const accountMockData.mockSubCommodityDatalist,
  spyOn(UBMCommonService, 'getSubCommodity').and.returnValue(of(accountMockData.mockSubCommodityDatalist));
  component.getSubCommodity();
  expect(component.getSubCommodity).toEqual([{mockSubCommodityDatalist}]);
});

it('should log an error when addAccount() fails', ()=>{
const errorMessage "Error adding an account!!!";
mockUBMService.addAccount.and.returnValue(throwError(() =>errorMessage));
spyon(console, 'log'); component.addAccount(); 
expect(console.log).toHaveBeenCalledwith(errorMessage);
});
accountForm

it('should return true if UBMLicense is active', () => {
  commonServiceMock.isModuleExistAndActiveInPackageLicense.and.returnValue(true);
  const result = UBMCommonService.checkUBMLicense();
  expect(result).toBeTrue();
});
it('should return false if UBMLicense is not active', () => {
  commonServiceMock.isModuleExistAndActiveInPackageLicense.and.returnValue(false);

  const result = UBMCommonService.checkUBMLicense();

  expect(result).toBeFalse();
});
it('should log an error when deleteAccount() fails', ()=>{
const errorMessage = "Error Deleting an account!!!";
mockUBMService.deleteAccount.and.returnValue(throwError(() =>errorMessage));
spyon(console, 'log'); component.deleteAccount(accountForm); 
expect(console.log).toHaveBeenCalledwith(errorMessage);
});

it('should delete an account when deleteAccount() is called', () => {
  component.accountGridData = [{ supplierAccountId: 1 }, { supplierAccountId: 2 }];
  component.accountDetails = { AccountId: 3 };
 showSuccess= "Delete confirmation for supplier accounts"
  const form: NgForm = { resetForm: jasmine.createSpy('resetForm') } as any;

  component.deleteAccount(form);

  mockUBMService.deleteAccount.and.returnValue(throwError(() =>showSuccess)); 
  expect(form.resetForm).toHaveBeenCalled();
expect(console.log).toHaveBeenCalledwith(errorMessage)
  expect(UBMCommonService.deleteAccount).not.toHaveBeenCalled(showSuccess);
});

it('delete an account when deleteAccount() is called', () => {
showSuccess = "Account delete success!";
  component.AccountGrid = [{ supplierAccountId: 1 }, { supplierAccountId: 2 }];
  component.Account = { AccountId: 1 };
showSuccess
  const form: NgForm = { resetForm: jasmine.createSpy('resetForm') } as any;

  component.deleteAccount(form);

 mockUBMService.deleteAccount.and.returnValue(throwError(() =>showSuccess)); 

  );
  expect(UBMCommonService.deleteAccount).toHaveBeenCalledWith(1);
  expect(component.accountGrid).toEqual([{ supplierAccountId: 2 }]);
  expect(form.resetForm).toHaveBeenCalled();
expect(UBMCommonService.deleteAccount).not.toHaveBeenCalled(showSuccess);
});
